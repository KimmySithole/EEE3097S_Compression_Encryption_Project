# EEE3097S_Compression_Encryption_Project
An ARM based digital IP using the STM32F0 to encrypt and compress the IMU data.
Remote sensing is the use of an autonomous device in a remote area to communicate with another network wirelessly. Remote sensing is critical in the Southern Ocean Seasonal Experiment’s (SCALE) endeavour to understand various environmental characteristics of the marginal ice zone in the Antarctic. The University of Cape Town’s (UCT) electrical engineering research group part of SCALE have built a remote sensing buoy that obtains data from the marginal ice zone. This buoy has been termed SHARC buoy and is built with an Inertial Measurement Unit (IMU) and a host of other sensors. The data from the sensors is transmitted through an iridium satellite modem. Transmission through an iridium modem is, however, quite costly. Therefore, the research group would like to compress the data from the IMU and, furthermore, encrypt the data. Our task is to design an ARM based digital IP (Intellectual Property) to compress and encrypt the data from the IMU to alleviate the costs of iridium modem transmission and ensure the data is protected in transit. 
# Chosen encryption algorithm:
The initial chosen algorithm was the Blowfish algorithm due to its lightweight characteristics. However, due to it not being the current standard, the AES encryption algorithm was then chosen. It is much more secure with a multitude of resources to aid with implementation.  
# Chosen compression algorithm:
The initial chosen compression algorithm was the XOR based compression. This compression however when implemented posed to have limitations that were unforeseen. The first limitation is in only being able to compress csv file. When later on the realisation that data might also be in txt format this posed as a limitation to the system. Another limitation was that there is little information on XOR based compression this resulted in very limited resources on the implementation of the code. Thereby this resulted in the debugging of the found code difficult. In the end we could not implement the decompression with the compression algorithm and therefore an alternate algorithm had to be found.  

The next best option algorithm to use was the dictionary algorithm as this is widely used and many information on it is found on the internet. With that being said we were able to find a dictionary algorithm that is able to compress all different types of files and decompress them. The code used for compression is the FastLZ compression which implements the LZ77 compression method part of dictionary. Although dictionary uses a more power than XOR compression, it is more efficient in that it works. It also allows for versatility and therefore accommodates the fact that for testing we use an ICM which is different from the Sharc buoy ICM. 
# How to run compression code:
Code for compression is written in c. The code runs on windows using the terminal. For compression, a csv or txt data format that only consists of numbers with the first block representing time is used as an input file. On Windows terminal make all is run to compile all the compression and decompression code blocks. To run compression 6pack –compression level input file output file is run on the terminal. This converts the csv or txt file to a the output file of any format (for testing a txt file was used) and therefore representing the compressed file. The compression code allows for benchmarking which can be indicated by inputting –mem where followed by compression level and input file. Decompression occurs by running 6unpack Compressed file. 
